# 一、树





## 1.1二叉树的遍历方式

### [144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

前序遍历是中间节点，左子树，右子树的顺序

````java
//递归
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> out = new ArrayList<Integer>();
        preorder(root,out);
        return out;
         
    }
    //递归preorder，不断add节点到out
    public void preorder(TreeNode root,List<Integer> out){
        if(root == null){
            return;
        }
        out.add(root.val);
        preorder(root.left,out);
        preorder(root.right,out);
    }
}

//迭代
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>(); //弄个数组
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();//维护一个栈，不断压入遍历到的中节点，然后往下处理其左子树，完事后按后进先出的次序返回上一个中节点，继续遍历其右子树，最终输出数组
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                res.add(node.val); // 数组里加当前作为中节点遍历到的数据
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return res; //输出数组
    }
}

````

#### 知识点：Linklist（queue,deque,stack）与ArrayList常用方法

涉及到堆栈，队列等操作，应该考虑用List

需要快速插入，删除元素,add,remove，LinedList只需要对指针进行修改即可,基于链表

需要快速随机访问元素,get,set，ArrayList可以随机定位，基于数组

````markdown
Deque（double ended queue）是一个双端队列，有三种用途
    普通队列先进先出      Deque queue = new LinkedList()等价=>Queue queue = new LinkedList()
    双端队列两端都可以进出 Deque deque = new LinkedList()
    堆栈后进先出          Deque stack = new LinkedList()
    
    
        功能                               queue                  deque                   
    -------------------------------普通队列操作-------------------------------------
将e插入队尾，成功返回ture，插满抛异常            add(e)              addLast(e)
将e插入队尾，成功返回ture，插满返回false        offer(e)            offerLast(e)
获取并移除队列的头部元素，队列为空抛出异常        remove()            removeFirst()
获取并移除队列的头部元素，队列为空返回null        poll()              pollFirst()
获取但是不移除队列头部元素，队列为空抛出异常      element()           getFirst()
获取但是不移除队列头部元素，队列为空返回null       peek()              peekFirst()
    ---------------------------------双端队列操作---------------------------------------
    注：在普通队列操作的基础上,把方法里的Last和First换下即为另一端的操作
    ---------------------------------堆栈操作---------------------------------------
    注：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。
        功能                               stack                  deque
       入栈                                                   addFirst(e)/push(e) 
       出栈                                                   removeFirst()/pop()    
       看看                                                   peekFirst()/peek()
````

````
ArrayList 常用方法：
new:    
List<Integer> res = new ArrayList<Integer>();//这句创建了一个ArrayList的对象后把上溯到了List。此时它是一个List对象了，有些ArrayList有但是List没有的属性和方法，它就不能再用了。
ArrayList<Integer> res = new ArrayList<Integer>();//创建一对象则保留了ArrayList的所有属性。


增加元素到链表中
boolean add(Object o)//在列表的末尾顺序添加元素，起始索引位置从0开始
void add(int index,Object o)//在指定的索引位置添加元素。索引位置必须介于0和列表中元素个数之间

Object get(int index)返回指定索引位置处的元素。取出的元素是Object类型，使用前需要进行强制类型转换
Object set(int index,Object o)指定下标进行修改其中的元素，返回的是修改前的对象
boolean remove(Object o)从列表中删除元素
Object remove(int index)从列表中删除指定位置元素，起始索引位置从0开始

int size()返回列表中的元素个数
boolean contains(Object o)判断列表中是否存在指定元素
boolean isEmpty()判断列表是否为空；

删除元素
remove(int index) :删除该列表中指定位置的元素。
removerAll(Collection c)从此列表中删除包含在指定集合中的所有元素
retainAll(Collection c) 仅保留此列表中包含在指定集合中的元素
boolean remove(Object o) 从列表中删除指定元素的第一个出现（如果存在）（可选操作）。  
boolean removeAll(Collection c) :从此列表中删除包含在指定集合中的所有元素（可选操作）。  
clear():从此列表中删除所有元素（可选操作）。 
````





## 1.2深度优先 DFS



### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

````java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){ 
            return 0;
        } 
		//此处有递归，递归计算出其左子树和右子树的最大深度，最后计算出当前二叉树的最大深度，递归在访问到空节点时退出
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left,right)+1;

    }
}
````





## 1.3广度优先 BFS



## 1.4**字典树** Trie



# 二、链表 LinkList

链表如何实现，如何遍历链表。链表可以保证头部尾部插入删除操作都是O（1），查找任意元素位置O（N）



# 三、数组 ArrayList



# 四、堆、栈、队列、哈希表、图

## 4.1堆 **Heap**

## 4.2栈 **Stack**

## 4.3队列 **Queue**

## 4.4哈希表 **HashMap、HashSet**

## 4.5图 Graph



# 五、排序 Sort

快速排序（Quick Sort）， 归并排序（Merge Sort）快速排序时间复杂度平均状态下O（NlogN），空间复杂度O（1），归并排序最坏情况下时间复杂度O（NlogN），空间复杂度O（N）



# 六、二分法



# 七、双指针



# 八、分治



# 九、递归

**递归是一种算法结构**，递归会出现在子程序中，形式上表现为直接或间接的自己调用自己；

# 十、迭代



# 十一、动态规划



# 十二、回溯法

**回溯是一种算法思想**，它是用**递归实现**的，回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。

## 12.1最大公约数 GCD

例：12，18的最大公约数是6

列举了一些求最大公约数(Greatest Common Divisor)的常用方法以及遇到的例题

### [1250. 检查「好数组」](https://leetcode.cn/problems/check-if-it-is-a-good-array/)

````java
//这题的重点主要是转化成求最大公约数，熟记求法模板
class Solution {
    public boolean isGoodArray(int[] nums) {
        int res = nums[0];
        for(int i = 1; i < nums.length; i++){
            res = gcd(res, nums[i]);
        }
        return res == 1;
    }
    private int gcd(int a, int b){
        return b == 0 ? a : gcd(b, a % b);
    }
}
````



#### 知识点：求最大公约数与最小公倍数的方法

求最大公约数：



递归三目运算符写法

此段代码a、b可以为0

```java
private int gcd(int a, int b){
    return b == 0 ? a : gcd(b, a % b);
}
```



求最小公倍数：

````java
private int gcd(int a, int b){
    return b == 0 ? a : gcd(b, a % b);
}
private int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
}
````



# 十三、查找



# 十四、滑动窗口



# 十五、前缀和

## 15.1前缀和+单调栈/哈希表

#### [1124. 表现良好的最长时间段 ](https://leetcode.cn/problems/longest-well-performing-interval/description/)

````java
//贪心
//hour>8的为1分，hour<=8的为-1分，题目转化为求解[区间分数和]大于0的最长区间长度。
//假设区间【l,r】通过维护一个栈 stack，从小到大来遍历存储前缀和更小的数的位置，然后从大到小遍历右端点位置r,求解可能成为最优区间的左端点位置l
class Solution {
    public int longestWPI(int[] hours) {
        int n = hours.length; 
        int[] s = new int[n + 1]; //这个是前缀和
        s[0] = 0;
        Deque<Integer> stack = new LinkedList<Integer>(); //维护一个栈
        stack.addFirst(0);//入栈一个0

        //顺序生成单调栈，栈中元素为 s[0]∼s[r−1] 的递减项
        for (int i = 1; i <= n; i++) {
            s[i] = s[i - 1] + (hours[i - 1] > 8 ? 1 : -1);//s[1]=s[0]+ 1或-1
            //求解最长一段区间使得s[前]<s[后]
            
            if (s[stack.peekFirst()] > s[i]) {//如果栈顶位置的前缀和大于该位置的前缀和
                stack.addFirst(i);//把该位置入栈
            }
        }
        //倒序扫描前缀和数组，求最大长度坡
        int res = 0;
        for (int r = n; r >= 1; r--) { //倒着
            while (!stack.isEmpty() && s[stack.peekFirst()] < s[r]) { //当栈不为空且栈顶位置的前缀和小于后边r位置的前缀和时
                res = Math.max(res, r - stack.removeFirst()); //更新答案并出栈
            }
        }
        return res;
    }
}
````

````java
//前缀和+哈希表
class Solution {
    public int longestWPI(int[] hours) {
        int n = hours.length;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int s = 0, res = 0;
        for (int i = 0; i < n; i++) {
            s += hours[i] > 8 ? 1 : -1;
            if (s > 0) {
                res = Math.max(res, i + 1);
            } else {
                if (map.containsKey(s - 1)) {
                    res = Math.max(res, i - map.get(s - 1));
                }
            }
            if (!map.containsKey(s)) {
                map.put(s, i);
            }
        }
        return res;
    }
}
````



##### 知识点：前缀和，单调栈，哈希表，最大长度坡

前缀和：

前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。 

核心：把数组nums索引前的累加和保存在一个新的presum数组中。presum[i]为nums[0...i-1]的和。

设b[]为前缀和数组，a[]为原数组，根据这句话可以得到前缀和的定义式和递推式：

|            | 定义式                                                       | 递推式                                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 一维前缀和 | ![b[i]=\sum_{j=0}^{i}a[j]](https://private.codecogs.com/gif.latex?b%5Bi%5D%3D%5Csum_%7Bj%3D0%7D%5E%7Bi%7Da%5Bj%5D) | ![b[i]=b[i-1]+a[i]](https://private.codecogs.com/gif.latex?b%5Bi%5D%3Db%5Bi-1%5D&plus;a%5Bi%5D) |
| 二维前缀和 | ![b[x][y]=\sum_{i=0}^{x}\sum_{j=0}^{y}a[i][j]](https://private.codecogs.com/gif.latex?b%5Bx%5D%5By%5D%3D%5Csum_%7Bi%3D0%7D%5E%7Bx%7D%5Csum_%7Bj%3D0%7D%5E%7By%7Da%5Bi%5D%5Bj%5D) | ![gif](C:\Users\wusha\Desktop\fsdownload\gif.gif)            |

 

【一维前缀和】

根据上面的定义，我们可以很容易得到 sum[i] = sum[i-1] + a[i] 　这样就可以得到前i个数的和

根据上述表达式我们可以以O(1)求出区间[i,j]的区间和   

![image-20230214152221830](C:\Users\wusha\AppData\Roaming\Typora\typora-user-images\image-20230214152221830.png)



单调栈：这里要用单调递减的栈,即之后入栈的都要比栈顶的元素小

哈希表：

最大长度坡：





# 十六、其他