# 一、树





## 1.1二叉树的遍历方式

### [144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

前序遍历是中间节点，左子树，右子树的顺序

````java
//递归
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> out = new ArrayList<Integer>();
        preorder(root,out);
        return out;
         
    }
    //递归preorder，不断add节点到out
    public void preorder(TreeNode root,List<Integer> out){
        if(root == null){
            return;
        }
        out.add(root.val);
        preorder(root.left,out);
        preorder(root.right,out);
    }
}

//迭代
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>(); //弄个数组
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();//维护一个栈，不断压入遍历到的中节点，然后往下处理其左子树，完事后按后进先出的次序返回上一个中节点，继续遍历其右子树，最终输出数组
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                res.add(node.val); // 数组里加当前作为中节点遍历到的数据
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return res; //输出数组
    }
}

````

#### 知识点：Linklist（queue,deque,stack）与ArrayList常用方法

涉及到堆栈，队列等操作，应该考虑用List

需要快速插入，删除元素,add,remove，LinedList只需要对指针进行修改即可,基于链表

需要快速随机访问元素,get,set，ArrayList可以随机定位，基于数组

````markdown
Deque（double ended queue）是一个双端队列，有三种用途
    普通队列先进先出      Deque queue = new LinkedList()等价=>Queue queue = new LinkedList()
    双端队列两端都可以进出 Deque deque = new LinkedList()
    堆栈后进先出          Deque stack = new LinkedList()
    
    
        功能                               queue                  deque                   
    -------------------------------普通队列操作-------------------------------------
将e插入队尾，成功返回ture，插满抛异常            add(e)              addLast(e)
将e插入队尾，成功返回ture，插满返回false        offer(e)            offerLast(e)
获取并移除队列的头部元素，队列为空抛出异常        remove()            removeFirst()
获取并移除队列的头部元素，队列为空返回null        poll()              pollFirst()
获取但是不移除队列头部元素，队列为空抛出异常      element()           getFirst()
获取但是不移除队列头部元素，队列为空返回null       peek()              peekFirst()
    ---------------------------------双端队列操作---------------------------------------
    注：在普通队列操作的基础上,把方法里的Last和First换下即为另一端的操作
    ---------------------------------堆栈操作---------------------------------------
    注：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。
        功能                               stack                  deque
       入栈                                                   addFirst(e)/push(e) 
       出栈                                                   removeFirst()/pop()    
       看看                                                   peekFirst()/peek()
````

````
ArrayList 常用方法：
new:    
List<Integer> res = new ArrayList<Integer>();//这句创建了一个ArrayList的对象后把上溯到了List。此时它是一个List对象了，有些ArrayList有但是List没有的属性和方法，它就不能再用了。
ArrayList<Integer> res = new ArrayList<Integer>();//创建一对象则保留了ArrayList的所有属性。


增加元素到链表中
boolean add(Object o)//在列表的末尾顺序添加元素，起始索引位置从0开始
void add(int index,Object o)//在指定的索引位置添加元素。索引位置必须介于0和列表中元素个数之间
Object get(int index)返回指定索引位置处的元素。取出的元素是Object类型，使用前需要进行强制类型转换
Object set(int index,Object o)指定下标进行修改其中的元素，返回的是修改前的对象
boolean remove(Object o)从列表中删除元素
Object remove(int index)从列表中删除指定位置元素，起始索引位置从0开始

int size()返回列表中的元素个数
boolean contains(Object o)判断列表中是否存在指定元素
boolean isEmpty()判断列表是否为空；

删除元素
remove(int index) :删除该列表中指定位置的元素。
	removerAll(Collection c)从此列表中删除包含在指定集合中的所有元素
	retainAll(Collection c) 仅保留此列表中包含在指定集合中的元素
boolean remove(Object o) 从列表中删除指定元素的第一个出现（如果存在）（可选操作）。  
boolean removeAll(Collection c) :从此列表中删除包含在指定集合中的所有元素（可选操作）。  
clear():从此列表中删除所有元素（可选操作）。 
````





## 1.2深度优先 DFS



### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

````java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){ 
            return 0;
        } 
		//此处有递归，递归计算出其左子树和右子树的最大深度，最后计算出当前二叉树的最大深度，递归在访问到空节点时退出
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left,right)+1;

    }
}
````





## 1.3广度优先 BFS



## 1.4**字典树** Trie



# 二、链表 LinkList

链表如何实现，如何遍历链表。链表可以保证头部尾部插入删除操作都是O（1），查找任意元素位置O（N）



# 三、数组 ArrayList



# 四、堆、栈、队列、哈希表、图

## 4.1堆 **Heap**

## 4.2栈 **Stack**

## 4.3队列 **Queue**

## 4.4哈希表 **HashMap、HashSet**

## 4.5图 Graph



# 五、排序 Sort

快速排序（Quick Sort）， 归并排序（Merge Sort）快速排序时间复杂度平均状态下O（NlogN），空间复杂度O（1），归并排序最坏情况下时间复杂度O（NlogN），空间复杂度O（N）



# 六、二分法



# 七、双指针



# 八、分治



# 九、递归



# 十、迭代



# 十一、动态规划



# 十二、回溯法



# 十三、查找



# 十四、滑动窗口



# 十五、前缀和



# 十六、其他