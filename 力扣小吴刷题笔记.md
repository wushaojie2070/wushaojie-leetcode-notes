# 一、树





## 1.1二叉树的遍历方式

### [144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

前序遍历是中间节点，左子树，右子树的顺序

````java
//递归
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> out = new ArrayList<Integer>();
        preorder(root,out);
        return out;
         
    }
    //递归preorder，不断add节点到out
    public void preorder(TreeNode root,List<Integer> out){
        if(root == null){
            return;
        }
        out.add(root.val);
        preorder(root.left,out);
        preorder(root.right,out);
    }
}

//迭代
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>(); //弄个数组
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();//维护一个栈，不断压入遍历到的中节点，然后往下处理其左子树，完事后按后进先出的次序返回上一个中节点，继续遍历其右子树，最终输出数组
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                res.add(node.val); // 数组里加当前作为中节点遍历到的数据
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return res; //输出数组
    }
}

````

#### 知识点：Linklist（queue,deque,stack）与ArrayList常用方法

涉及到堆栈，队列等操作，应该考虑用List

需要快速插入，删除元素,add,remove，LinedList只需要对指针进行修改即可,基于链表

需要快速随机访问元素,get,set，ArrayList可以随机定位，基于数组

````markdown
Deque（double ended queue）是一个双端队列，有三种用途
    普通队列先进先出      Deque<Integer> queue = new LinkedList()等价=>Queue queue = new LinkedList<Integer>()
    双端队列两端都可以进出 Deque<Integer> deque = new LinkedList<Integer>()
    堆栈后进先出          Deque<Integer> stack = new LinkedList<Integer>()
    
    
        功能                               queue                  deque                   
    -------------------------------普通队列操作-------------------------------------
将e插入队尾，成功返回ture，插满抛异常            add(e)              addLast(e)
将e插入队尾，成功返回ture，插满返回false        offer(e)            offerLast(e)
获取并移除队列的头部元素，队列为空抛出异常        remove()            removeFirst()
获取并移除队列的头部元素，队列为空返回null        poll()              pollFirst()
获取但是不移除队列头部元素，队列为空抛出异常      element()           getFirst()
获取但是不移除队列头部元素，队列为空返回null       peek()              peekFirst()
    ---------------------------------双端队列操作---------------------------------------
    注：在普通队列操作的基础上,把方法里的Last和First换下即为另一端的操作
    ---------------------------------堆栈操作---------------------------------------
    注：Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。
        功能                               stack                  deque
       入栈                                                   addFirst(e)/push(e) 
       出栈                                                   removeFirst()/pop()    
       看看                                                   peekFirst()/peek()
````

````
ArrayList 常用方法：
new:    
List<Integer> res = new ArrayList<Integer>();//这句创建了一个ArrayList的对象后把上溯到了List。此时它是一个List对象了，有些ArrayList有但是List没有的属性和方法，它就不能再用了。
ArrayList<Integer> res = new ArrayList<Integer>();//创建一对象则保留了ArrayList的所有属性。


增加元素到链表中
boolean add(Object o)//在列表的末尾顺序添加元素，起始索引位置从0开始
void add(int index,Object o)//在指定的索引位置添加元素。索引位置必须介于0和列表中元素个数之间

Object get(int index)返回指定索引位置处的元素。取出的元素是Object类型，使用前需要进行强制类型转换
Object set(int index,Object o)指定下标进行修改其中的元素，返回的是修改前的对象
boolean remove(Object o)从列表中删除元素
Object remove(int index)从列表中删除指定位置元素，起始索引位置从0开始

int size()返回列表中的元素个数
boolean contains(Object o)判断列表中是否存在指定元素
boolean isEmpty()判断列表是否为空；

删除元素
remove(int index) :删除该列表中指定位置的元素。
removerAll(Collection c)从此列表中删除包含在指定集合中的所有元素
retainAll(Collection c) 仅保留此列表中包含在指定集合中的元素
boolean remove(Object o) 从列表中删除指定元素的第一个出现（如果存在）（可选操作）。  
boolean removeAll(Collection c) :从此列表中删除包含在指定集合中的所有元素（可选操作）。  
clear():从此列表中删除所有元素（可选操作）。 
````





## 1.2深度优先 DFS



### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

````java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){ 
            return 0;
        } 
		//此处有递归，递归计算出其左子树和右子树的最大深度，最后计算出当前二叉树的最大深度，递归在访问到空节点时退出
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left,right)+1;

    }
}
````





## 1.3广度优先 BFS



## 1.4**字典树** Trie



# 二、链表 LinkList

链表如何实现，如何遍历链表。链表可以保证头部尾部插入删除操作都是O（1），查找任意元素位置O（N）



# 三、数组 ArrayList



# 四、堆、栈、队列、哈希表、图

## 4.1堆 **Heap**

## 4.2栈 **Stack**

### 4.2.1 单调栈

#### [739. 每日温度 ](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

 解法1：单调栈

````java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        //单调栈  找下一个更大元素的索引距离
        Deque<Integer> stack = new LinkedList<Integer>();
        int[] arr = new int[n];
        // 从后往前遍历
        for(int i = n-1; i >= 0; i--){
            //若栈内有值 且 现在的值>=栈顶的值，一直出栈，直到出完或者栈顶的值更大
            while(!stack.isEmpty() && temperatures[stack.peekFirst()] <= temperatures[i]){
                stack.removeFirst();
            }
            //若栈内没值则给0，若有值则计算距离存起来，入栈
            arr[i] = stack.isEmpty() ? 0 : (stack.peekFirst() - i);
            stack.addFirst(i);
        }
        return arr;

    }
}
````

分析：

当逆序遍历的过程中时：堆栈里存放这从后往前已经遍历过的内容。

1. 若当前的元素小于堆栈顶元素，那么这个元素不会挡住任何一个堆栈里的元素。把该元素放到堆栈里。

2. 若当前的元素大于堆栈顶端元素，那么就说明<font color='red'> 后面一定有元素被挡住了</font>，后面出现了无用的元素。

   ```kotlin
    1. 把所有小于该元素的元素都pop出去。因为这些元素对于前面的元素而言已经没有用了。
    2. 找到比他大的元素，计算中间间隔几天，并return
   ```

最后需要特殊处理一下 stack是empty的情况

上面的可以整合为一个逻辑：

```cpp
先把stack的栈顶pop到恰好大于当前的元素的位置上。
然后return 当前元素 与 栈顶恰好比其大的元素 之间的距离
```

示例：

````java
T = [73,74,75,71,69,72,76,73]

第一次遍历: i = 7, T[i] = 73, stack = []
        最后一天，后面没有比今天温度高的 res[7] = 0 ,stack = [7]

第二次遍历: i = 6, T[i] = 76, stack = [7]
        栈顶对应的温度T[7]=73,76>73,出栈,此时栈为空,加入6,res[6] = 0, stack = [6]

第三次遍历: i = 5, T[i] = 72, stack = [6]
        栈顶对应的温度T[6]=76,满足要求,计算结果后入栈。res[5] = 6-5, stack = [6,5]

第四次遍历: i = 4, T[i] = 69, stack = [6,5]
        栈顶对应的温度T[5]=72,满足要求,计算结果后入栈。res[4] = 5-4, stack = [6,5,4]

第五次遍历: i = 3, T[i] = 71, stack = [6,5,4]
        栈顶对应的温度T[4]=69,71>69,出栈。stack = [6,5]
        栈顶对应的温度T[5]=72,满足要求,计算结果后入栈。res[3] = 5-3, stack = [6,5,3]

第六次遍历: i = 2, T[i] = 75, stack = [6,5,3]
        栈顶对应的温度T[3]=71,75>71,出栈。stack = [6,5]
        栈顶对应的温度T[5]=72,75>72,出栈。stack = [6]
        栈顶对应的温度T[6]=76,满足要求,计算结果后入栈。res[2] = 6-2, stack = [6,2]

第七次遍历: i = 1, T[i] = 74, stack = [6,2]
        栈顶对应的温度T[2]=75,满足要求,计算结果后入栈。res[1] = 2-1, stack = [6,2,1]

第八次遍历: i = 0, T[i] = 73, stack = [6,2,1]
        栈顶对应的温度T[1]=74,满足要求,计算结果后入栈。res[0] = 1-0, stack = [6,2,1,0]

遍历结束: res = [1,1,4,2,1,1,0,0]

````



## 4.3队列 **Queue**

## 4.4哈希表 **HashMap、HashSet**

### 4.4.1HashMap

HashMap 是一个散列表，它存储的内容是键值(key-value)映射。
HashMap 的 key 与 value 类型可以相同也可以不同，根据定义，不受限制。



#### 知识点：常用方法

````java
Map<String, Integer> map = new HashMap<String, Integer>();
//增删改查

//添加数据
//map.put(key,value)
map.put("赵祯", 23) ;
map.put("老刘", 88) ;
map.put("Lisi",92);

//获取数据
int value = map.get("赵祯") ;

//当Map集合中有这个key时，就使用这个key对应的value值，如果没有就使用默认值defaultValue；
hashmap.getOrDefault(key,defaultValue);

//获取Map中键值对的个数
int size = map.size() ;

//判断Map集合中是否包含键为key的键值对
boolean b1 = map.containsKey("赵祯") ;  //true

//判断Map集合中是否包含值为value的键值对
boolean b3=map.containsValue(23);  //true

//根据键值删除Map中键值对
int value2=map.remove("Lisi");  //92

//清空Map集合中所有的键值对
map.clear();

//判断Map集合中是否没有任何键值对【是否为空】
boolean b5=map.isEmpty(); //true

//替换 hashMap 中是指定的key对应的 value
hashmap.replace("赵祯","赵政"); // 返回"赵祯"


// entrySet() 方法可以与 for-each 循环一起使用，用来遍历迭代 HashMap 中每一个映射项
for(var entry : map.entrySet()){
    // 获得key
    int key = entry.getKey();
	// 获得value
	int value = entry.getValue();
}


````



#### 遍历HashMap

````java
//迭代
Map map = new HashMap();
　　Iterator iter = map.entrySet().iterator();
　　while (iter.hasNext()) {
　　Map.Entry entry = (Map.Entry) iter.next();
　　Object key = entry.getKey();
　　Object val = entry.getValue();
　　}
//for
Map<String, String> map = new HashMap<String, String>();
for (Entry<String, String> entry : map.entrySet()) {
	entry.getKey();
	entry.getValue();
}
````



### 4.4.2HashSet



#### 知识点：常用方法

````java
Set<Integer> hashset= new HashSet<Integer>();

//添加值（增）
hashset.add(1);

//迭代存入元素
int[] nums = new int[]{1,2,3,4,5,6}
for(int x : nums) hash.add(x);

//删除元素（删）
hashmap.remove(1);

hashmap.clear();


````







## 4.5图 Graph



# 五、排序 Sort

快速排序（Quick Sort）， 归并排序（Merge Sort）快速排序时间复杂度平均状态下O（NlogN），空间复杂度O（1），归并排序最坏情况下时间复杂度O（NlogN），空间复杂度O（N）



# 六、二分法



# 七、双指针



# 八、分治



# 九、递归



# 十、迭代



# 十一、动态规划



# 十二、回溯法



# 十三、查找



# 十四、滑动窗口



# 十五、前缀和

## 15.1前缀和+单调栈/哈希表

#### [1124. 表现良好的最长时间段 ](https://leetcode.cn/problems/longest-well-performing-interval/description/)

````java
//贪心，前缀和+单调栈
//hour>8的为1分，hour<=8的为-1分，题目转化为求解[区间分数和]大于0的最长区间长度。
//假设区间【l,r】通过维护一个栈 stack，从小到大来遍历存储前缀和更小的数的位置，然后从大到小遍历右端点位置r,求解可能成为最优区间的左端点位置l
//维护一个单调栈，使栈顶元素始终>=遍历值，以算距离
class Solution {
    public int longestWPI(int[] hours) {
        int n = hours.length; 
        int[] s = new int[n + 1]; //这个是前缀和
        s[0] = 0;
        Deque<Integer> stack = new LinkedList<Integer>(); //维护一个栈
        stack.addFirst(0);//入栈一个0

        //顺序生成单调栈，栈中元素为 s[0]∼s[r−1] 的递减项
        for (int i = 1; i <= n; i++) {
            s[i] = s[i - 1] + (hours[i - 1] > 8 ? 1 : -1);//s[1]=s[0]+ 1或-1
            //求解最长一段区间使得s[前]<s[后]
            
            if (s[stack.peekFirst()] > s[i]) {//如果栈顶位置的前缀和大于该位置的前缀和
                stack.addFirst(i);//把该位置入栈
            }
        }
        //倒序扫描前缀和数组，求最大长度坡
        int res = 0;
        for (int r = n; r >= 1; r--) { //倒着
            while (!stack.isEmpty() && s[stack.peekFirst()] < s[r]) { //当栈不为空且栈顶位置的前缀和小于后边r位置的前缀和时
                res = Math.max(res, r - stack.removeFirst()); //更新答案并出栈
            }
        }
        return res;
    }
}
````

````java
//前缀和+哈希表
class Solution {
    public int longestWPI(int[] hours) {
        int n = hours.length;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int s = 0, res = 0;
        for (int i = 0; i < n; i++) {
            s += hours[i] > 8 ? 1 : -1;
            if (s > 0) {
                result = i + 1;
            } else {
                if (map.containsKey(s - 1)) {
                    res = Math.max(res, i - map.get(s - 1));
                }
            }
            if (!map.containsKey(s)) {
                map.put(s, i);
            }
        }
        return res;
    }
}
````

````java
//前缀和+数组 chatGPT给的答案


把前缀和都加上了 n，使得负数可以用数组索引表示，同时避免了数组越界的问题。
````



##### 知识点：前缀和，单调栈，哈希表，最大长度坡

前缀和：

前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。 

核心：把数组nums索引前的累加和保存在一个新的presum数组中。presum[i]为nums[0...i-1]的和。

设b[]为前缀和数组，a[]为原数组，根据这句话可以得到前缀和的定义式和递推式：

|            | 定义式                                                       | 递推式                                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 一维前缀和 | ![b[i]=\sum_{j=0}^{i}a[j]](https://private.codecogs.com/gif.latex?b%5Bi%5D%3D%5Csum_%7Bj%3D0%7D%5E%7Bi%7Da%5Bj%5D) | ![b[i]=b[i-1]+a[i]](https://private.codecogs.com/gif.latex?b%5Bi%5D%3Db%5Bi-1%5D&plus;a%5Bi%5D) |
| 二维前缀和 | ![b[x][y]=\sum_{i=0}^{x}\sum_{j=0}^{y}a[i][j]](https://private.codecogs.com/gif.latex?b%5Bx%5D%5By%5D%3D%5Csum_%7Bi%3D0%7D%5E%7Bx%7D%5Csum_%7Bj%3D0%7D%5E%7By%7Da%5Bi%5D%5Bj%5D) | ![gif](C:\Users\wusha\Desktop\fsdownload\gif.gif)            |

 

【一维前缀和】

根据上面的定义，我们可以很容易得到 sum[i] = sum[i-1] + a[i] 　这样就可以得到前i个数的和

根据上述表达式我们可以以O(1)求出区间[i,j]的区间和   

![image-20230214152221830](C:\Users\wusha\AppData\Roaming\Typora\typora-user-images\image-20230214152221830.png)



单调栈：这里要用单调递减的栈,即之后入栈的都要比栈顶的元素小

哈希表：

最大长度坡：





# 十六、其他